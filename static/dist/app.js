/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./js/app.js":
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _controller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./controller.js */ \"./js/controller.js\");\n\nlet controller;\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    controller = new _controller_js__WEBPACK_IMPORTED_MODULE_0__.Controller();\n});\n\n\n//# sourceURL=webpack:///./js/app.js?");

/***/ }),

/***/ "./js/board.js":
/*!*********************!*\
  !*** ./js/board.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Board: () => (/* binding */ Board)\n/* harmony export */ });\n/* harmony import */ var _msTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./msTypes.js */ \"./js/msTypes.js\");\n\nclass Cell {\n    constructor(fieldTypeActual, fieldTypeVisible) {\n        this.fieldTypeActual = fieldTypeActual;\n        this.fieldTypeVisible = fieldTypeVisible;\n    }\n    toString() {\n        return this.fieldTypeVisible;\n    }\n}\nclass Board {\n    constructor(width, height, mines) {\n        this.width = width;\n        this.height = height;\n        this.mines = mines;\n        this.grid = Array.from({ length: this.height }, () => Array.from({ length: this.width }, () => new Cell(_msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.EMPTY, _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.UNKNOWN)));\n        this.gameState = _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.GameState.INIT;\n        this.numRevealedCells = 0;\n        this.minesLeft = mines;\n    }\n    generateBoard(pos) {\n        const allPositions = [];\n        for (let i = 0; i < this.height; i++) {\n            for (let j = 0; j < this.width; j++) {\n                if (i !== pos[0] || j !== pos[1]) {\n                    allPositions.push([i, j]);\n                }\n            }\n        }\n        // Place mines\n        const minePositions = this.getRandomElements(allPositions, this.mines);\n        minePositions.forEach(([i, j]) => {\n            this.grid[i][j] = new Cell(_msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.MINE, _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.UNKNOWN);\n        });\n        // Fill the rest of the board\n        for (let i = 0; i < this.height; i++) {\n            for (let j = 0; j < this.width; j++) {\n                if (this.grid[i][j].fieldTypeActual === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.MINE)\n                    continue;\n                const mineCount = this.countMines(i, j);\n                this.grid[i][j] = new Cell(_msTypes_js__WEBPACK_IMPORTED_MODULE_0__.NUM_TO_FIELD_TYPE[mineCount], _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.UNKNOWN);\n            }\n        }\n    }\n    getRandomElements(arr, n) {\n        // Create a copy of the array to avoid modifying the original\n        const shuffled = [...arr];\n        // Implement Fisher-Yates shuffle\n        for (let i = shuffled.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n        }\n        return shuffled.slice(0, n);\n    }\n    countMines(i, j) {\n        return Board.ALL_MOVES.reduce((count, [dx, dy]) => {\n            var _a;\n            const x = i + dx;\n            const y = j + dy;\n            if (this.isValidPosition(x, y) &&\n                ((_a = this.grid[x][y]) === null || _a === void 0 ? void 0 : _a.fieldTypeActual) === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.MINE) {\n                return count + 1;\n            }\n            return count;\n        }, 0);\n    }\n    isValidPosition(x, y) {\n        return x >= 0 && x < this.height && y >= 0 && y < this.width;\n    }\n    putFlag(pos) {\n        if (this.gameState === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.GameState.INIT) {\n            this.generateBoard(pos);\n            this.gameState = _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.GameState.PLAYING;\n        }\n        const [i, j] = pos;\n        const cell = this.grid[i][j];\n        if (!(cell.fieldTypeVisible === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.UNKNOWN ||\n            cell.fieldTypeVisible === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.FLAG))\n            return;\n        if (this.gameState === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.GameState.PLAYING) {\n            if (this.grid[i][j].fieldTypeVisible === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.FLAG) {\n                this.grid[i][j].fieldTypeVisible = _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.UNKNOWN;\n                this.minesLeft++;\n            }\n            else {\n                this.grid[i][j].fieldTypeVisible = _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.FLAG;\n                this.minesLeft--;\n            }\n        }\n    }\n    revealCell(pos) {\n        if (this.gameState === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.GameState.INIT) {\n            this.generateBoard(pos);\n            this.gameState = _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.GameState.PLAYING;\n        }\n        if (this.gameState !== _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.GameState.PLAYING) {\n            return false;\n        }\n        const [i, j] = pos;\n        const selectedCell = this.grid[i][j];\n        if (selectedCell.fieldTypeVisible !== _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.UNKNOWN)\n            return false;\n        if (selectedCell.fieldTypeActual === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.MINE) {\n            this.gameState = _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.GameState.LOST;\n            this.revealAll();\n            this.grid[i][j].fieldTypeVisible = _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.MINE_SELECTED;\n            return false;\n        }\n        else if (selectedCell.fieldTypeActual === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.EMPTY) {\n            this.revealEmptyCells(pos);\n        }\n        else {\n            selectedCell.fieldTypeVisible = selectedCell.fieldTypeActual;\n            this.numRevealedCells++;\n        }\n        if (this.numRevealedCells === this.width * this.height - this.mines) {\n            this.gameState = _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.GameState.WON;\n            this.revealAll();\n            return false;\n        }\n        return true;\n    }\n    revealEmptyCells(pos) {\n        const [i, j] = pos;\n        const cell = this.grid[i][j];\n        if (!(cell.fieldTypeActual === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.EMPTY))\n            return;\n        cell.fieldTypeVisible = cell.fieldTypeActual;\n        this.numRevealedCells++;\n        Board.ALL_MOVES.forEach(([dx, dy]) => {\n            const x = i + dx;\n            const y = j + dy;\n            if (this.isValidPosition(x, y) &&\n                this.grid[x][y].fieldTypeVisible === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.UNKNOWN) {\n                this.revealCell([x, y]);\n            }\n        });\n    }\n    revealAll() {\n        for (let i = 0; i < this.height; i++) {\n            for (let j = 0; j < this.width; j++) {\n                if (this.grid[i][j].fieldTypeActual === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.MINE) {\n                    if (this.grid[i][j].fieldTypeVisible === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.FLAG) {\n                        this.grid[i][j].fieldTypeVisible = _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.FLAG;\n                    }\n                    else {\n                        this.grid[i][j].fieldTypeVisible = _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.MINE;\n                    }\n                }\n                else {\n                    if (this.grid[i][j].fieldTypeVisible === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.FLAG) {\n                        this.grid[i][j].fieldTypeVisible = _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.MINE_WRONG;\n                    }\n                    else {\n                        this.grid[i][j].fieldTypeVisible = this.grid[i][j].fieldTypeActual;\n                    }\n                }\n            }\n        }\n    }\n    getBoardRepr() {\n        return this.grid.map((row) => row.map((cell) => cell.fieldTypeVisible));\n    }\n    getDimensions() {\n        return [this.width, this.height];\n    }\n    getNumberOfMines() {\n        return this.mines;\n    }\n    toString() {\n        return this.grid\n            .map((row) => row.map((cell) => cell.toString()).join(\" \"))\n            .join(\"\\n\");\n    }\n    getState() {\n        return {\n            gameState: this.gameState,\n            gameBoard: this.getBoardRepr(),\n            minesLeft: this.minesLeft,\n        };\n    }\n    getCell(pos) {\n        return this.grid[pos[0]][pos[1]].fieldTypeVisible;\n    }\n}\nBoard.STRAIGHT_MOVES = [[-1, 0], [1, 0], [0, -1], [0, 1],\n];\nBoard.DIAGONAL_MOVES = [[-1, -1], [-1, 1], [1, -1], [1, 1],\n];\nBoard.ALL_MOVES = [\n    ...Board.STRAIGHT_MOVES,\n    ...Board.DIAGONAL_MOVES,\n];\n\n\n//# sourceURL=webpack:///./js/board.js?");

/***/ }),

/***/ "./js/controller.js":
/*!**************************!*\
  !*** ./js/controller.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Controller: () => (/* binding */ Controller)\n/* harmony export */ });\n/* harmony import */ var _model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model.js */ \"./js/model.js\");\n/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view.js */ \"./js/view.js\");\n\n\nclass Controller {\n    constructor() {\n        this.model = new _model_js__WEBPACK_IMPORTED_MODULE_0__.Model();\n        this.view = new _view_js__WEBPACK_IMPORTED_MODULE_1__.View();\n        this.view.render(this.model.getState());\n        this.refreshTimer = null;\n        this.startTimer();\n        this.view.startGameDefaultButton.forEach((button) => {\n            button.addEventListener(\"click\", () => {\n                this.startGameDefault(parseInt(button.getAttribute(\"data-width\")), parseInt(button.getAttribute(\"data-height\")), parseInt(button.getAttribute(\"data-mines\")));\n            });\n        });\n        this.view.startGameCustomButton.addEventListener(\"click\", () => {\n            this.startGameCustom();\n        });\n        this.view.gameBoardDiv.addEventListener(\"click\", (e) => {\n            this.handleCellClick(e);\n        });\n        this.view.gameBoardDiv.addEventListener(\"contextmenu\", (e) => {\n            e.preventDefault(); // Prevent context menu from appearing\n            this.handleCellRightClick(e);\n        });\n        this.view.gameRestartButton.addEventListener(\"click\", () => {\n            this.restartGame();\n        });\n        this.view.gameMenuButton.addEventListener(\"click\", () => {\n            this.showMenu();\n        });\n        this.view.showProbabilityButton.addEventListener(\"click\", () => {\n            this.showProbability();\n        });\n    }\n    startGameDefault(width, height, mines) {\n        this.model.startGame(width, height, mines);\n        this.view.render(this.model.getState());\n    }\n    startGameCustom() {\n        const width = parseInt(this.view.widthInputField.value);\n        const height = parseInt(this.view.heightInputField.value);\n        const mines = parseInt(this.view.minesInputField.value);\n        this.model.startGame(width, height, mines);\n        this.view.render(this.model.getState());\n    }\n    handleCellClick(e) {\n        const [x, y] = this.getMousePosition(e);\n        if (x !== -1 && y !== -1) {\n            this.model.revealCell([x, y]).then(() => {\n                this.view.render(this.model.getState());\n            });\n            this.view.render(this.model.getState());\n        }\n    }\n    handleCellRightClick(event) {\n        const [x, y] = this.getMousePosition(event);\n        if (x !== -1 && y !== -1) {\n            this.model.putFlag([x, y]);\n            this.view.render(this.model.getState());\n        }\n    }\n    restartGame() {\n        this.model.restartGame();\n        this.view.resetGame();\n        this.view.render(this.model.getState());\n    }\n    showMenu() {\n        this.model.showMenu();\n        this.view.resetGame();\n        this.view.render(this.model.getState());\n    }\n    showProbability() {\n        const isButtonPressed = this.model.toggleProbability();\n        this.view.render(this.model.getState());\n        if (isButtonPressed) {\n            this.view.activateProbabilityButton();\n        }\n        else {\n            this.view.deactivateProbabilityButton();\n        }\n    }\n    getMousePosition(event) {\n        const cell = event.target.closest(\".grid-item\");\n        if (!cell)\n            return [-1, -1];\n        const x = parseInt(cell.getAttribute(\"data-x\") || \"-1\");\n        const y = parseInt(cell.getAttribute(\"data-y\") || \"-1\");\n        return [x, y];\n    }\n    startTimer() {\n        this.refreshTimer = window.setInterval(() => {\n            this.view.renderTime(this.model.getState().time);\n        }, 1000);\n    }\n}\n\n\n//# sourceURL=webpack:///./js/controller.js?");

/***/ }),

/***/ "./js/model.js":
/*!*********************!*\
  !*** ./js/model.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Model: () => (/* binding */ Model)\n/* harmony export */ });\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board.js */ \"./js/board.js\");\n/* harmony import */ var _solver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./solver.js */ \"./js/solver.js\");\n/* harmony import */ var _msTypes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./msTypes.js */ \"./js/msTypes.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nclass Model {\n    constructor() {\n        this.board = new _board_js__WEBPACK_IMPORTED_MODULE_0__.Board(0, 0, 0);\n        this.solver = null;\n        this.probabilityBoard = null;\n        this.showProbability = false;\n        this.timer = null;\n        this.timeInitial = 0;\n        this.timeCurrent = 0;\n    }\n    startGame(width, height, mines) {\n        this.showProbability = false;\n        this.board = new _board_js__WEBPACK_IMPORTED_MODULE_0__.Board(width, height, mines);\n        this.solver = null;\n        this.startTimer();\n    }\n    getBoard() {\n        return this.board;\n    }\n    getState() {\n        if (this.board.getDimensions()[0] !== 0 && this.board.getDimensions()[1] !== 0) {\n            return {\n                boardState: this.board.getState(),\n                probabilityBoardState: this.showProbability ? this.probabilityBoard : null,\n                time: this.timeCurrent,\n            };\n        }\n        return {\n            boardState: {\n                gameState: _msTypes_js__WEBPACK_IMPORTED_MODULE_2__.GameState.MENU,\n                gameBoard: [],\n                minesLeft: 0,\n            },\n            probabilityBoardState: this.showProbability ? this.probabilityBoard : null,\n            time: this.timeCurrent,\n        };\n    }\n    revealCell(pos) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d;\n            const moveDone = (_b = (_a = this.board) === null || _a === void 0 ? void 0 : _a.revealCell(pos)) !== null && _b !== void 0 ? _b : false;\n            if (moveDone) {\n                if (this.solver == null) {\n                    this.solver = new _solver_js__WEBPACK_IMPORTED_MODULE_1__.Solver(this.board);\n                    Promise.resolve((_c = this.solver) === null || _c === void 0 ? void 0 : _c.getProbabilities()).then((x) => {\n                        this.probabilityBoard = x !== null && x !== void 0 ? x : null;\n                    });\n                }\n                else {\n                    yield this.solver.updateBoard(this.board.getBoardRepr()).then(() => {\n                        var _a;\n                        Promise.resolve((_a = this.solver) === null || _a === void 0 ? void 0 : _a.getProbabilities()).then((x) => {\n                            this.probabilityBoard = x !== null && x !== void 0 ? x : null;\n                        });\n                    });\n                }\n            }\n            if (((_d = this.board) === null || _d === void 0 ? void 0 : _d.getState().gameState) !== _msTypes_js__WEBPACK_IMPORTED_MODULE_2__.GameState.PLAYING) {\n                this.probabilityBoard = null;\n                this.showProbability = false;\n                this.stopTimer();\n            }\n        });\n    }\n    putFlag(pos) {\n        var _a;\n        (_a = this.board) === null || _a === void 0 ? void 0 : _a.putFlag(pos);\n    }\n    restartGame() {\n        var _a, _b, _c, _d;\n        const [width, height] = (_b = (_a = this.board) === null || _a === void 0 ? void 0 : _a.getDimensions()) !== null && _b !== void 0 ? _b : [0, 0];\n        const mines = (_d = (_c = this.board) === null || _c === void 0 ? void 0 : _c.getNumberOfMines()) !== null && _d !== void 0 ? _d : 0;\n        this.board = new _board_js__WEBPACK_IMPORTED_MODULE_0__.Board(width, height, mines);\n        this.solver = null;\n        this.probabilityBoard = null;\n        this.startTimer();\n    }\n    showMenu() {\n        this.board = new _board_js__WEBPACK_IMPORTED_MODULE_0__.Board(0, 0, 0);\n        this.solver = null;\n    }\n    toggleProbability() {\n        this.showProbability = !this.showProbability;\n        return this.showProbability;\n    }\n    resetTime() {\n        this.timeInitial = performance.now();\n        this.timeCurrent = 0;\n    }\n    startTimer() {\n        this.stopTimer();\n        this.resetTime();\n        this.timer = window.setInterval(() => {\n            if (this.board.getState().gameState === _msTypes_js__WEBPACK_IMPORTED_MODULE_2__.GameState.PLAYING) {\n                this.timeCurrent = Math.floor((performance.now() - this.timeInitial) / Model.TIMER_INTERVAL);\n            }\n            else {\n                this.timeCurrent = 0;\n                this.timeInitial = performance.now();\n            }\n        }, Model.TIMER_INTERVAL);\n    }\n    stopTimer() {\n        if (this.timer) {\n            window.clearInterval(this.timer);\n            this.timer = null;\n        }\n    }\n}\nModel.TIMER_INTERVAL = 1000; // ms\n\n\n//# sourceURL=webpack:///./js/model.js?");

/***/ }),

/***/ "./js/msTypes.js":
/*!***********************!*\
  !*** ./js/msTypes.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CELL_TO_NUMBER: () => (/* binding */ CELL_TO_NUMBER),\n/* harmony export */   FieldType: () => (/* binding */ FieldType),\n/* harmony export */   GameState: () => (/* binding */ GameState),\n/* harmony export */   NOT_NUM_TYPES: () => (/* binding */ NOT_NUM_TYPES),\n/* harmony export */   NUM_TO_FIELD_TYPE: () => (/* binding */ NUM_TO_FIELD_TYPE),\n/* harmony export */   cellIsANumber: () => (/* binding */ cellIsANumber)\n/* harmony export */ });\nvar FieldType;\n(function (FieldType) {\n    FieldType[\"MINE\"] = \"mine\";\n    FieldType[\"EMPTY\"] = \"empty\";\n    FieldType[\"NUMBER\"] = \"number\";\n    FieldType[\"ONE\"] = \"one\";\n    FieldType[\"TWO\"] = \"two\";\n    FieldType[\"THREE\"] = \"three\";\n    FieldType[\"FOUR\"] = \"four\";\n    FieldType[\"FIVE\"] = \"five\";\n    FieldType[\"SIX\"] = \"six\";\n    FieldType[\"SEVEN\"] = \"seven\";\n    FieldType[\"EIGHT\"] = \"eight\";\n    FieldType[\"UNKNOWN\"] = \"unknown\";\n    FieldType[\"FLAG\"] = \"flag\";\n    FieldType[\"MINE_WRONG\"] = \"mine-wrong\";\n    FieldType[\"MINE_SELECTED\"] = \"mine-selected\";\n    FieldType[\"MINE_CALCULATED\"] = \"mine-calculated\";\n})(FieldType || (FieldType = {}));\nconst NOT_NUM_TYPES = new Set([\n    FieldType.UNKNOWN,\n    FieldType.MINE,\n    FieldType.FLAG,\n    FieldType.EMPTY,\n    FieldType.NUMBER,\n]);\nconst NUM_TO_FIELD_TYPE = {\n    0: FieldType.EMPTY,\n    1: FieldType.ONE,\n    2: FieldType.TWO,\n    3: FieldType.THREE,\n    4: FieldType.FOUR,\n    5: FieldType.FIVE,\n    6: FieldType.SIX,\n    7: FieldType.SEVEN,\n    8: FieldType.EIGHT,\n};\nconst CELL_TO_NUMBER = {\n    [FieldType.ONE]: 1,\n    [FieldType.TWO]: 2,\n    [FieldType.THREE]: 3,\n    [FieldType.FOUR]: 4,\n    [FieldType.FIVE]: 5,\n    [FieldType.SIX]: 6,\n    [FieldType.SEVEN]: 7,\n    [FieldType.EIGHT]: 8,\n    [FieldType.MINE]: 1000,\n    [FieldType.EMPTY]: 1000,\n    [FieldType.NUMBER]: 10000,\n    [FieldType.UNKNOWN]: 100000,\n    [FieldType.FLAG]: 100000,\n    [FieldType.MINE_WRONG]: 100000,\n    [FieldType.MINE_SELECTED]: 100000,\n    [FieldType.MINE_CALCULATED]: 100000,\n};\nvar GameState;\n(function (GameState) {\n    GameState[\"MENU\"] = \"M\";\n    GameState[\"INIT\"] = \"I\";\n    GameState[\"PLAYING\"] = \"P\";\n    GameState[\"WON\"] = \"W\";\n    GameState[\"LOST\"] = \"L\";\n})(GameState || (GameState = {}));\nconst cellIsANumber = (cell) => {\n    return (cell === FieldType.ONE ||\n        cell === FieldType.TWO ||\n        cell === FieldType.THREE ||\n        cell === FieldType.FOUR ||\n        cell === FieldType.FIVE ||\n        cell === FieldType.SIX ||\n        cell === FieldType.SEVEN ||\n        cell === FieldType.EIGHT);\n};\n\n\n//# sourceURL=webpack:///./js/msTypes.js?");

/***/ }),

/***/ "./js/solver.js":
/*!**********************!*\
  !*** ./js/solver.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Solver: () => (/* binding */ Solver)\n/* harmony export */ });\n/* harmony import */ var _board_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board.js */ \"./js/board.js\");\n/* harmony import */ var _msTypes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./msTypes.js */ \"./js/msTypes.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass Solver {\n    constructor(board) {\n        this.boardCurrent = board.getBoardRepr();\n        [this.width, this.height] = board.getDimensions();\n        this.minesLeftCalculated = board.getNumberOfMines();\n        this.mineProbability = this.boardCurrent.map((row) => row.map((cell) => (cell === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.MINE ? 1 : 0.0)));\n        this.isProbabilityCalculated = false;\n        this.detachedCells = new Set(Array.from({ length: this.height }, (_, i) => Array.from({ length: this.width }, (_, j) => `${i},${j}`)).flat());\n        this.updateDetachedCells();\n    }\n    updateBoard(board) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (let i = 0; i < this.height; i++) {\n                for (let j = 0; j < this.width; j++) {\n                    if (board[i][j] !== _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.UNKNOWN && board[i][j] !== _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.FLAG) {\n                        this.boardCurrent[i][j] = board[i][j];\n                        this.mineProbability[i][j] =\n                            board[i][j] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.MINE ? 1.0 : 0.0;\n                    }\n                }\n                this.updateDetachedCells();\n            }\n            yield this.solve();\n        });\n    }\n    solve() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let updateStack = this.basicStrategy();\n            while (updateStack.length > 0) {\n                for (const [x, y, fieldType] of updateStack) {\n                    if (fieldType === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.NUMBER) {\n                        this.boardCurrent[x][y] = _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.NUMBER;\n                        this.mineProbability[x][y] = 0.0;\n                    }\n                    else if (fieldType === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.MINE_CALCULATED && !(this.boardCurrent[x][y] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.MINE_CALCULATED || this.boardCurrent[x][y] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.MINE)) {\n                        this.boardCurrent[x][y] = _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.MINE_CALCULATED;\n                        this.mineProbability[x][y] = 1.0;\n                        this.minesLeftCalculated--;\n                    }\n                }\n                updateStack = this.basicStrategy();\n            }\n            const perimeters = this.getPerimeters();\n            let f = 1;\n            const idxMapArray = [];\n            const solutionArray = [];\n            for (const perimeter of perimeters) {\n                const [A, b, idxToLoc] = this.getEquation(perimeter);\n                if (A.length === 0) {\n                    continue;\n                }\n                const solutionList = yield this.solvingBin(A, b);\n                if (solutionList.length === 0) {\n                    continue;\n                }\n                solutionArray.push(solutionList);\n                idxMapArray.push(idxToLoc);\n                f *= solutionList.length;\n                const nBits = A[0].length;\n                let commonMine = Math.pow(2, nBits) - 1;\n                let commonEmpty = Math.pow(2, nBits) - 1;\n                for (const solution of solutionList) {\n                    commonMine &= parseInt(solution, 2);\n                    commonEmpty &= ~parseInt(solution, 2);\n                }\n                const commonEmptyBin = commonEmpty.toString(2).padStart(nBits, \"0\");\n                const commonMineBin = commonMine.toString(2).padStart(nBits, \"0\");\n                for (let i = 0; i < nBits; i++) {\n                    const [x, y] = idxToLoc[i];\n                    if (commonEmptyBin[i] === \"1\") {\n                        this.mineProbability[x][y] = 0.0;\n                        this.boardCurrent[x][y] = _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.NUMBER;\n                    }\n                    else if (commonMineBin[i] === \"1\" && !(this.boardCurrent[x][y] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.MINE_CALCULATED || this.boardCurrent[x][y] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.MINE)) {\n                        this.mineProbability[x][y] = 1.0;\n                        this.boardCurrent[x][y] = _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.MINE_CALCULATED;\n                        this.minesLeftCalculated--;\n                    }\n                }\n            }\n            // Calculate the probability of mines on the board using arrangements\n            let total = 0;\n            const globalMineProbability = this.boardCurrent.map((row) => row.map((cell) => -1));\n            let expectedNumberOfMinesOnPerimeter = 0;\n            const detachedCells = this.getNumberOfDetachedCells();\n            const dfsSolutions = (level, currentSolutionArray) => {\n                if (level === solutionArray.length) {\n                    let minesUsed = 0;\n                    const cellLocation = [];\n                    for (let i = 0; i < currentSolutionArray.length; i++) {\n                        const solution = currentSolutionArray[i];\n                        minesUsed += solution.split('').filter((x) => x === '1').length;\n                        const idxMap = idxMapArray[i];\n                        for (const [idx, loc] of Object.entries(idxMap)) {\n                            if (solution.charAt(parseInt(idx)) === '1') {\n                                cellLocation.push(loc);\n                            }\n                        }\n                    }\n                    // this should not be possible\n                    if (this.minesLeftCalculated - minesUsed < 0) {\n                        return;\n                    }\n                    const possibleCount = this.nCr(detachedCells, this.minesLeftCalculated - minesUsed);\n                    total += possibleCount;\n                    for (const cell of cellLocation) {\n                        globalMineProbability[cell[0]][cell[1]] += possibleCount;\n                    }\n                    expectedNumberOfMinesOnPerimeter += minesUsed * possibleCount;\n                    return;\n                }\n                for (const solution of solutionArray[level]) {\n                    currentSolutionArray.push(solution);\n                    dfsSolutions(level + 1, currentSolutionArray);\n                    currentSolutionArray.pop();\n                }\n            };\n            dfsSolutions(0, []);\n            for (let i = 0; i < this.height; i++) {\n                for (let j = 0; j < this.width; j++) {\n                    if (!(this.boardCurrent[i][j] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.UNKNOWN || this.boardCurrent[i][j] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.FLAG)) {\n                        continue;\n                    }\n                    if (globalMineProbability[i][j] === -1) {\n                        this.mineProbability[i][j] = (this.minesLeftCalculated - (expectedNumberOfMinesOnPerimeter / total)) / this.getNumberOfDetachedCells();\n                    }\n                    else {\n                        this.mineProbability[i][j] = (globalMineProbability[i][j] + 1) / total;\n                    }\n                }\n            }\n        });\n    }\n    getProbabilities() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isProbabilityCalculated) {\n                this.isProbabilityCalculated = true;\n                yield this.solve();\n            }\n            return this.mineProbability;\n        });\n    }\n    basicStrategy() {\n        const updateStack = [];\n        for (let x = 0; x < this.height; x++) {\n            for (let y = 0; y < this.width; y++) {\n                const cell = this.boardCurrent[x][y];\n                if (!(0,_msTypes_js__WEBPACK_IMPORTED_MODULE_1__.cellIsANumber)(cell))\n                    continue;\n                let numMinesNeighbours = _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.CELL_TO_NUMBER[cell];\n                let numUnknownNeighbours = 0;\n                let numMinesDiscovered = 0;\n                const unknownNeighbours = [];\n                for (const [dx, dy] of _board_js__WEBPACK_IMPORTED_MODULE_0__.Board.ALL_MOVES) {\n                    const nx = x + dx;\n                    const ny = y + dy;\n                    if (this.isValidCell(nx, ny)) {\n                        if (this.boardCurrent[nx][ny] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.UNKNOWN || this.boardCurrent[nx][ny] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.FLAG) {\n                            numUnknownNeighbours++;\n                            unknownNeighbours.push([nx, ny]);\n                        }\n                        else if (this.boardCurrent[nx][ny] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.MINE || this.boardCurrent[nx][ny] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.MINE_CALCULATED) {\n                            numMinesDiscovered++;\n                        }\n                    }\n                }\n                if (numMinesDiscovered === numMinesNeighbours) {\n                    for (const [nx, ny] of unknownNeighbours) {\n                        updateStack.push([nx, ny, _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.NUMBER]);\n                    }\n                }\n                else if (numUnknownNeighbours === numMinesNeighbours - numMinesDiscovered) {\n                    for (const [nx, ny] of unknownNeighbours) {\n                        updateStack.push([nx, ny, _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.MINE_CALCULATED]);\n                    }\n                }\n            }\n        }\n        return updateStack;\n    }\n    getPerimeters() {\n        const visitedMask = Array.from({ length: this.height }, () => Array.from({ length: this.width }, () => false));\n        let perimeterList = [];\n        for (let i = 0; i < this.height; i++) {\n            for (let j = 0; j < this.width; j++) {\n                if (((0,_msTypes_js__WEBPACK_IMPORTED_MODULE_1__.cellIsANumber)(this.boardCurrent[i][j]) || this.boardCurrent[i][j] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.EMPTY) || visitedMask[i][j] || !this.adjacentToSolid(i, j))\n                    continue;\n                const perimeter = new Set();\n                const stack = [[i, j]];\n                while (stack.length > 0) {\n                    const [x, y] = stack.shift();\n                    visitedMask[x][y] = true;\n                    const canGo = new Set();\n                    for (const [dx, dy] of _board_js__WEBPACK_IMPORTED_MODULE_0__.Board.ALL_MOVES) {\n                        const nx = x + dx;\n                        const ny = y + dy;\n                        if (this.isValidCell(nx, ny) && (0,_msTypes_js__WEBPACK_IMPORTED_MODULE_1__.cellIsANumber)(this.boardCurrent[nx][ny])) {\n                            if (Math.abs(dx) + Math.abs(dy) == 1) {\n                                if (Math.abs(dx) == 1) {\n                                    canGo.add(`${0},${1}`);\n                                    canGo.add(`${0},${-1}`);\n                                }\n                                else {\n                                    canGo.add(`${1},${0}`);\n                                    canGo.add(`${-1},${0}`);\n                                }\n                            }\n                            else {\n                                canGo.add(`${dx},${0}`);\n                                canGo.add(`${0},${dy}`);\n                            }\n                            perimeter.add(`${nx},${ny}`);\n                        }\n                    }\n                    for (const dir of canGo) {\n                        const [dx, dy] = dir.split(',').map(Number);\n                        const nx = x + dx;\n                        const ny = y + dy;\n                        if (this.isValidCell(nx, ny) && !visitedMask[nx][ny] && this.adjacentToSolid(nx, ny) && (this.boardCurrent[nx][ny] == _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.UNKNOWN || this.boardCurrent[nx][ny] == _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.FLAG || this.boardCurrent[nx][ny] == _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.MINE || this.boardCurrent[nx][ny] == _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.MINE_CALCULATED)) {\n                            stack.push([nx, ny]);\n                            visitedMask[nx][ny] = true;\n                        }\n                    }\n                }\n                const overlap = [];\n                for (const coord of perimeter) {\n                    let idx = 0;\n                    for (const otherPerimeter of perimeterList) {\n                        if (otherPerimeter.has(coord)) {\n                            overlap.push(idx);\n                        }\n                        idx++;\n                    }\n                }\n                for (const idx of overlap) {\n                    perimeterList[idx].forEach(coord => perimeter.add(coord));\n                }\n                perimeterList = perimeterList.filter((_, idx) => !overlap.includes(idx));\n                perimeterList.push(perimeter);\n            }\n        }\n        return perimeterList.map(perimeter => Array.from(perimeter).map(coord => {\n            const [x, y] = coord.split(',').map(Number);\n            return [x, y];\n        }));\n    }\n    getEquation(perimeter) {\n        const A = [];\n        const b = [];\n        let maxLenA = 0;\n        const locToIdx = {};\n        let AMatrixIdx = 0;\n        for (const [x, y] of perimeter) {\n            b.push(_msTypes_js__WEBPACK_IMPORTED_MODULE_1__.CELL_TO_NUMBER[this.boardCurrent[x][y]]);\n            A.push(Array(maxLenA).fill(0));\n            for (const [dx, dy] of _board_js__WEBPACK_IMPORTED_MODULE_0__.Board.ALL_MOVES) {\n                const nx = x + dx;\n                const ny = y + dy;\n                if (this.isValidCell(nx, ny)) {\n                    if (this.boardCurrent[nx][ny] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.MINE_CALCULATED ||\n                        this.boardCurrent[nx][ny] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.MINE) {\n                        b[b.length - 1]--;\n                    }\n                    else if (this.boardCurrent[nx][ny] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.UNKNOWN || this.boardCurrent[nx][ny] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.FLAG) {\n                        const key = `${nx},${ny}`;\n                        if (!(key in locToIdx)) {\n                            locToIdx[key] = AMatrixIdx++;\n                            maxLenA++;\n                            A[A.length - 1].push(0);\n                        }\n                        const idx = locToIdx[key];\n                        A[A.length - 1][idx] = 1;\n                    }\n                }\n            }\n        }\n        // Pad arrays to make them equal length\n        const Afinal = [];\n        const bfinal = [];\n        let cnt = -1;\n        for (const row of A) {\n            cnt++;\n            if (row.every((x) => x === 0)) {\n                continue;\n            }\n            const padding = Array.from({ length: maxLenA - row.length }, () => 0);\n            Afinal.push([...row, ...padding]);\n            bfinal.push(b[cnt]);\n        }\n        // Create reverse mapping\n        const idxToLoc = {};\n        for (const [loc, idx] of Object.entries(locToIdx)) {\n            const [x, y] = loc.split(\",\").map(Number);\n            idxToLoc[idx] = [x, y];\n        }\n        return [Afinal, bfinal, idxToLoc];\n    }\n    solvingBin(A, b) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (A.length === 0) {\n                return Promise.resolve([]);\n            }\n            const t1 = performance.now();\n            const solutions = [];\n            const Ab = A.map((row, i) => [...row, b[i]]);\n            const Aechelon = this.toEchelonForm(Ab);\n            const Areduced = [];\n            const breduced = [];\n            // Remove rows with all zeros\n            for (let idx = 0; idx < Aechelon.length; idx++) {\n                if (Aechelon[idx].every((x, idx) => x === 0 || idx === Aechelon[0].length - 1)) {\n                    continue;\n                }\n                Areduced.push(Aechelon[idx].slice(0, -1));\n                breduced.push(Aechelon[idx][Aechelon[idx].length - 1]);\n            }\n            const backtrack = (pos, current) => {\n                // if we reached the end, it means all equations are satisfied and we have a solution\n                if (pos === Areduced.length) {\n                    solutions.push(current.join(''));\n                    return;\n                }\n                const candidates = [];\n                candidates.push([current, 0]);\n                let knowSum = 0;\n                for (let idx = 0; idx < Areduced[pos].length; idx++) {\n                    const coeff = Areduced[pos][idx];\n                    // if the coefficient is 0, it means the unknown variable b[idx] is not used in the equation, and there is no point in using it or assuming any value for it\n                    if (coeff === 0)\n                        continue;\n                    // if the value is already known (from previous equations), we can add it to the sum\n                    if (current[idx] !== null) {\n                        knowSum += current[idx] * coeff;\n                        continue;\n                    }\n                    const candSize = candidates.length;\n                    // for every current candidate, create two new candidates, one with the value 1 and one with the value 0 for the unknown variable at position idx\n                    for (let i = 0; i < candSize; i++) {\n                        const [candidate, sum] = candidates.shift();\n                        candidate[idx] = 1;\n                        candidates.push([candidate.slice(0), sum + coeff]);\n                        candidate[idx] = 0;\n                        candidates.push([candidate, sum]);\n                    }\n                }\n                for (const [candidate, sum] of candidates) {\n                    // if equation is satisfied, we can continue to the next equation\n                    if (sum + knowSum === breduced[pos]) {\n                        backtrack(pos + 1, candidate);\n                    }\n                }\n            };\n            backtrack(0, Array(Areduced[0].length).fill(null));\n            const t2 = performance.now();\n            console.debug(\"Time to solve: \", t2 - t1);\n            return solutions;\n        });\n    }\n    updateDetachedCells() {\n        const cellsToRemove = [];\n        for (const pos of this.detachedCells) {\n            const [x, y] = pos.split(',').map(Number);\n            let isDetachedCell = true;\n            if (!this.isUndiscoveredCell(x, y)) {\n                isDetachedCell = false;\n            }\n            else {\n                for (const [dx, dy] of _board_js__WEBPACK_IMPORTED_MODULE_0__.Board.ALL_MOVES) {\n                    const nx = x + dx;\n                    const ny = y + dy;\n                    if (this.isValidCell(nx, ny) && ((0,_msTypes_js__WEBPACK_IMPORTED_MODULE_1__.cellIsANumber)(this.boardCurrent[nx][ny]) || this.boardCurrent[nx][ny] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.EMPTY)) {\n                        isDetachedCell = false;\n                        break;\n                    }\n                }\n            }\n            if (!isDetachedCell) {\n                cellsToRemove.push(`${x},${y}`);\n            }\n        }\n        for (const cellKey of cellsToRemove) {\n            this.detachedCells.delete(cellKey);\n        }\n    }\n    getNumberOfDetachedCells() {\n        return this.detachedCells.size;\n    }\n    isValidCell(x, y) {\n        return x >= 0 && x < this.height && y >= 0 && y < this.width;\n    }\n    isUndiscoveredCell(x, y) {\n        return this.boardCurrent[x][y] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.UNKNOWN || this.boardCurrent[x][y] === _msTypes_js__WEBPACK_IMPORTED_MODULE_1__.FieldType.FLAG;\n    }\n    nCr(n, r) {\n        if (r > n) {\n            throw new Error(\"r cannot be greater than n.\");\n        }\n        r = Math.min(r, n - r); // Use symmetry property\n        let result = 1;\n        for (let i = 0; i < r; i++) {\n            result *= (n - i);\n            result /= (i + 1);\n        }\n        return result;\n    }\n    adjacentToSolid(x, y) {\n        for (const [dx, dy] of _board_js__WEBPACK_IMPORTED_MODULE_0__.Board.ALL_MOVES) {\n            const nx = x + dx;\n            const ny = y + dy;\n            if (this.isValidCell(nx, ny) && ((0,_msTypes_js__WEBPACK_IMPORTED_MODULE_1__.cellIsANumber)(this.boardCurrent[nx][ny]))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    toEchelonForm(matrix) {\n        const rowCount = matrix.length;\n        const colCount = matrix[0].length;\n        let lead = 0; // The leading column index\n        for (let r = 0; r < rowCount; r++) {\n            if (lead >= colCount) {\n                return matrix;\n            }\n            let i = r;\n            while (matrix[i][lead] === 0) {\n                i++;\n                if (i === rowCount) {\n                    i = r;\n                    lead++;\n                    if (lead === colCount) {\n                        return matrix;\n                    }\n                }\n            }\n            // Swap rows i and r\n            [matrix[i], matrix[r]] = [matrix[r], matrix[i]];\n            // Normalize the pivot row\n            const lv = matrix[r][lead];\n            for (let j = 0; j < colCount; j++) {\n                matrix[r][j] /= lv;\n            }\n            // Make all rows below the pivot have a 0 in the current column\n            for (let i = 0; i < rowCount; i++) {\n                if (i !== r) {\n                    const lv = matrix[i][lead];\n                    for (let j = 0; j < colCount; j++) {\n                        matrix[i][j] -= lv * matrix[r][j];\n                    }\n                }\n            }\n            lead++;\n        }\n        return matrix;\n    }\n}\n\n\n//# sourceURL=webpack:///./js/solver.js?");

/***/ }),

/***/ "./js/view.js":
/*!********************!*\
  !*** ./js/view.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   View: () => (/* binding */ View)\n/* harmony export */ });\n/* harmony import */ var _msTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./msTypes.js */ \"./js/msTypes.js\");\n\nclass View {\n    constructor() {\n        this.menuDiv = document.getElementById(\"menu-container\");\n        this.gameDiv = document.getElementById(\"game-container\");\n        this.widthInputField = document.getElementById(\"width\");\n        this.heightInputField = document.getElementById(\"height\");\n        this.minesInputField = document.getElementById(\"mines\");\n        this.startGameDefaultButton =\n            document.querySelectorAll(\".play-game-default\");\n        this.startGameCustomButton = document.querySelector(\".play-game-custom\");\n        this.gameHeaderDiv = document.getElementById(\"game-header\");\n        this.minesLeftDiv = document.getElementById(\"mines-left\");\n        this.timerDiv = document.getElementById(\"timer\");\n        this.gameBoardDiv = document.getElementById(\"game-board\");\n        this.showProbabilityButton = document.getElementById(\"show-probability-btn\");\n        this.gameOutcomeDiv = document.getElementById(\"game-outcome\");\n        this.gameRestartButton = document.getElementById(\"restart-btn\");\n        this.gameMenuButton = document.getElementById(\"menu-btn\");\n    }\n    render(state) {\n        switch (state.boardState.gameState) {\n            case _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.GameState.MENU:\n                this.renderMenu();\n                break;\n            case _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.GameState.INIT:\n                this.initGameRender(state);\n                break;\n            case _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.GameState.PLAYING:\n                this.renderGame(state);\n                break;\n            case _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.GameState.LOST:\n                this.renderGame(state);\n                this.renderOutcome(state);\n                break;\n            case _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.GameState.WON:\n                this.renderGame(state);\n                this.renderOutcome(state);\n                break;\n        }\n    }\n    resetGame() {\n        this.gameOutcomeDiv.style.display = \"none\";\n        this.gameOutcomeDiv.innerHTML = \"\";\n        this.gameBoardDiv.replaceChildren();\n        this.gameOutcomeDiv.classList.remove(\"win-message\", \"lose-message\");\n        this.showProbabilityButton.classList.remove(\"active\");\n    }\n    renderMenu() {\n        this.menuDiv.style.display = \"block\";\n        this.gameDiv.style.display = \"none\";\n    }\n    initGameRender(state) {\n        this.menuDiv.style.display = \"none\";\n        this.gameDiv.style.display = \"block\";\n        this.gameBoardDiv.replaceChildren();\n        this.gameOutcomeDiv.style.display = \"none\";\n        this.gameOutcomeDiv.innerHTML = \"\";\n        let x = 0;\n        let y = 0;\n        for (let row of state.boardState.gameBoard) {\n            y = 0;\n            const rowDiv = document.createElement(\"div\");\n            rowDiv.classList.add(\"grid-container\");\n            rowDiv.style.gridTemplateColumns = `repeat(${state.boardState.gameBoard[0].length}, 1fr)`;\n            for (let cell of row) {\n                const cellDiv = document.createElement(\"div\");\n                cellDiv.id = `cell-${x}-${y}`;\n                cellDiv.classList.add(\"grid-item\");\n                cellDiv.setAttribute(\"data-value\", `cell-${cell.valueOf().toLowerCase()}`);\n                cellDiv.setAttribute(\"data-x\", x.toString());\n                cellDiv.setAttribute(\"data-y\", y.toString());\n                rowDiv.appendChild(cellDiv);\n                y++;\n            }\n            this.gameBoardDiv.appendChild(rowDiv);\n            x++;\n        }\n    }\n    renderGame(state) {\n        this.menuDiv.style.display = \"none\";\n        this.gameDiv.style.display = \"block\";\n        this.minesLeftDiv.innerHTML = state.boardState.minesLeft.toString();\n        this.renderTime(state.time);\n        let x = 0;\n        let y = 0;\n        const showProbability = state.probabilityBoardState !== null;\n        for (let row of Array.from(this.gameBoardDiv.children)) {\n            y = 0;\n            for (let cell of Array.from(row.children)) {\n                cell.setAttribute(\"data-value\", `cell-${state.boardState.gameBoard[x][y].valueOf().toLowerCase()}`);\n                if (showProbability && state.boardState.gameBoard[x][y] === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.UNKNOWN && state.probabilityBoardState !== null) {\n                    cell.style.backgroundColor = this.getProbabilityColor(state.probabilityBoardState[x][y]);\n                }\n                else if (state.boardState.gameBoard[x][y] === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.FLAG || (0,_msTypes_js__WEBPACK_IMPORTED_MODULE_0__.cellIsANumber)(state.boardState.gameBoard[x][y]) || state.boardState.gameBoard[x][y] === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.UNKNOWN || state.boardState.gameBoard[x][y] === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.MINE) {\n                    cell.style.backgroundColor = \"#d3d3d3\";\n                }\n                else if (state.boardState.gameBoard[x][y] === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.EMPTY) {\n                    cell.style.backgroundColor = \"#c0c0c0\";\n                }\n                else if (state.boardState.gameBoard[x][y] === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.FieldType.MINE_SELECTED) {\n                    cell.style.backgroundColor = \"red\";\n                }\n                y++;\n            }\n            x++;\n        }\n    }\n    renderOutcome(state) {\n        this.gameOutcomeDiv.style.display = \"block\";\n        this.gameOutcomeDiv.classList.add(state.boardState.gameState === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.GameState.WON ? \"win-message\" : \"lose-message\");\n        this.gameOutcomeDiv.innerHTML =\n            state.boardState.gameState === _msTypes_js__WEBPACK_IMPORTED_MODULE_0__.GameState.WON ? \"You won!\" : \"You lost!\";\n    }\n    activateProbabilityButton() {\n        this.showProbabilityButton.classList.add(\"active\");\n    }\n    deactivateProbabilityButton() {\n        this.showProbabilityButton.classList.remove(\"active\");\n    }\n    getProbabilityColor(probability) {\n        if (probability === null) {\n            probability = -1;\n        }\n        const hue = (1 - probability) * 240;\n        return `hsl(${hue}, 100%, 50%)`;\n    }\n    renderTime(time) {\n        this.timerDiv.innerHTML = `${Math.floor(time / 60).toString().padStart(2, '0')}:${(time % 60).toString().padStart(2, '0')}`;\n    }\n}\n\n\n//# sourceURL=webpack:///./js/view.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./js/app.js");
/******/ 	
/******/ })()
;